<!doctype html>
<html lang="en">
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

		<title>Modelling the Cosmos in Ruby</title>

		<link rel="stylesheet" href="dist/reset.css">
		<link rel="stylesheet" href="dist/reveal.css">
		<link rel="stylesheet" href="dist/theme/beige.css">
    <link rel="stylesheet" href="custom.css">

		<!-- Theme used for syntax highlighted code -->
		<link rel="stylesheet" href="plugin/highlight/obsidian.css">
	</head>
	<body>
		<div class="reveal">
			<div class="slides">
        <section>
          <h1>Modelling the Cosmos in Ruby</h1>
        </section>
        <section>
          <h2>The sky is a lie</h2>
        </section>
        <section>
          <p>We see what's in the past</p>
          <aside class="notes">
            <p>
              Because the speed of light is finite, everything we see is at
              least slightly in the past. When it comes to astronomy, delay can
              be seconds, minutes, days, years.
            </p>
          </aside>
        </section>
        <section>
          <p>Sunrise and sunset times are fake</p>
          <aside class="notes">
            <p>
              The atmosphere refracts light so much that when we witness a
              Sunset, the Sun has actually set below the horizon for several
              minutes.
            </p>
          </aside>
        </section>
        <section>
          <p>The Pole Star is not at the celestial pole</p>
          <aside class="notes">
            <p>
              From our perspective, the Pole Star slightly wobbles around the
              celestial pole. Thousands of years ago, another star was way
              closer to this point.
            </p>
          </aside>
        </section>
        <section>
          <p>A day is not 24 hours</p>
          <aside class="notes">
            <p>
              The Earth rotates around its axis in 23 hours, 56 minutes and 4
              seconds. What we use in everyday life is called a mean solar day,
              because the actual solar day varies throughout the year.
            </p>
          </aside>
        </section>
        <section>
          <p>Build an accurate astronomy library with that</p>
          <p>
            <img src="img/cringe.png" style="width: 400px">
          </p>
        </section>
        <section>
          <h2>Hi, I'm R√©my</h2>
        </section>
        <section>
          <p>Senior developer at thoughtbot</p>
        </section>
        <section>
          <p>In love with astronomy</p>
        </section>
        <section>
          <p>Let's meet and talk about <strike>food</strike> code</p>
        </section>
        <section>
          <h2>What are we going to talk about?</h2>
        </section>
        <section>
          <p>Complex domain models</p>
          <aside class="notes">
            <p>
              Astronomy is a complex domain, it's a good example to illustrate
              the challenges of domain modelling.
            </p>
          </aside>
        </section>
        <section>
          <p>Learn code design techniques</p>
          <aside class="notes">
            <p>
              We will learn about some code design techniques like oriented
              object design and domain driven design.
            </p>
          </aside>
        </section>
        <section>
          <p>Code readability for collaboration and education</p>
          <aside class="notes">
            <p>
              We will see how to write code that is easy to read and
              understand, so that we can share it with others.
            </p>
          </aside>
        </section>
        <section>
          <h2>Context: Astronoby</h2>
        </section>
        <section>
          <p>Astronomical data and events accessible in Ruby</p>
        </section>
        <section>
          <p>Position of planets in the sky ü™ê</p>
          <p>üåÖ Rising, transit and setting times üåÑ</p>
          <p>Equinoxes and solstices times ‚òÄÔ∏è</p>
          <p>Moon phases üåô</p>
        </section>
        <section>
          <p>Future:</p>
          <p>Conjunctions, oppositions</p>
          <p>Eclipses</p>
          <p>Deep sky objects</p>
          <p>Stargazing planner</p>
        </section>
        <section>
          <p>Increase scientific support in the Ruby ecosystem</p>
          <aside class="notes">
            <p>
              Python and Ruby are very close to each other, except some syntax
              differences and some features, they can basically do the same. But
              Ruby is not known for its scientific ecosystem, Python is. Ruby
              deserves to have scientific projects to inspire other so
              contribute to the ecosystem as one where science can happen.
            </p>
          </aside>
        </section>
        <section>
          <p>Approach</p>
          <p>Good idiomatic Ruby code</p>
          <p>Readable and educational code</p>
          <aside class="notes">
            <p>
              The goal is not to only write algorithms in Ruby and to write them
              in a way that is readable and understandable. I aim to write code
              that can explain the mechanisms behind the algorithms by itself.
            </p>
          </aside>
        </section>
        <section>
          <h2>
            Domain-Driven Design<br>
            and OOP<br>
            in Astronoby
          </h2>
        </section>
        <section>
          <p>Why?</p>
        </section>
        <section>
          <p>Azimuth: 123¬∞44‚Ä≤47‚Ä≥</p>
          <p>Altitude: 49¬∞26‚Ä≤13‚Ä≥</p>
        </section>
        <section>
          <p><img src="img/mars.png" alt="Mars" style="width: 200px"></p>
          <p><img src="img/geneva.jpg" alt="Geneva" style="width: 500px"></p>
          <aside class="notes">
            <p>
              These are coordinates of planet Mars seen from Geneva when we
              started this talk.
            </p>
            <p>
              Let me present you the suite of physical notions and data
              manipulations that were needed to get to this point.
            </p>
          </aside>
        </section>
        <section>
          <div class="row">
            <div class="col-35 smaller-text">
              <p>
                <span>Solar System Barycenter</span>
                <span><br>Vector</span>
                <span><br>Light-time</span>
                <span><br>Precession</span>
                <span><br>Nutation</span>
                <span><br>Aberration</span>
                <span><br>Deflection</span>
                <span><br>Earth shape</span>
                <span><br>Terrestrial time</span>
              </p>
            </div>
            <div class="col-65 small-text">
              <p>Barycentric position</p>
              <p>Geocentric astrometric position</p>
              <p>Geocentric apparent position</p>
              <p>Topocentric apparent position</p>
              <p>Equatorial coordinates</p>
              <p>Horizontal coordinates</p>
            </div>
          </div>
        </section>
        <section>
          <p>
            How to deal with a large and complex domain?
          </p>
          <aside class="notes">
            <p>
              This was my complexe example but I am sure you face and will face
              many other domains as and more complexe in your carrer.
            </p>
            <p>
              How to keep up with so many different notions? You need to define
              clearly the data you manipulate to be sure you're applying the
              right correction on the right object and extract the right data
              from it.
            </p>
          </aside>
        </section>
        <section>
          <h2>Domain-Driven Design</h2>
          <aside class="notes">
            <p>That's where Domain-Driven Design comes.</p>
          </aside>
        </section>
        <section>
          <p>Introduced in 2003 by Eric Evans</p>
          <p>Reflects business domain</p>
          <p>Focus on core domain</p>
          <aside class="notes">
            <p>
              Domain-Driven Design is a development approach that focuses on
              creating systems that deeply reflect the underlying business
              domain they serve.
            </p>
            <p>
              It was introduced in 2003 by Eric Evans his book "Domain-Driven
              Design: Tackling Complexity in the Heart of Software"
            </p>
            <p>
              The main philosophy is focus on the core domain, its logic, its
              meaning, and build an architecture that reflects it.
            </p>
          </aside>
        </section>
        <section>
          <div class="row">
            <div class="col">
              <p>‚ùå</p>
              <p class="fragment visible" data-fragment-index="0">
                <small>Technical layers</small>
              </p>
              <p class="fragment visible" data-fragment-index="2">
                <small>Large exhaustive models</small>
              </p>
              <p class="fragment visible" data-fragment-index="4">
                <small>Uniform objects</small>
              </p>
            </div>
            <div class="col">
              <p>‚úÖ</p>
              <p class="fragment visible" data-fragment-index="1">
                <small>Business concepts</small>
              </p>
              <p class="fragment visible" data-fragment-index="3">
                <small>Multiple models with explicit boudaries</small>
              </p>
              <p class="fragment visible" data-fragment-index="5">
                <small>Entities and value objects</small>
              </p>
            </div>
          </div>
          <aside class="notes">
            <p>
              Domain-Driven Design fundamentally shifts how we approach software
              development. Instead of organizing code around technical concerns
              like databases and UI layers, DDD encourages us to structure our
              systems around the actual business concepts and processes they
              represent.
            </p>
            <p>
              We move away from monolithic models and technical jargon, toward
              bounded contexts with explicit boundaries and a shared language
              that both developers and business experts use consistently.
            </p>
            <p>
              The code itself becomes a reflection of how the business thinks
              and operates. Instead of treating all objects the same way, we
              distinguish between identity-based entities and attribute-based
              value objects.
            </p>
          </aside>
        </section>
        <section>
          <h3>Ubiquitous Language</h3>
          <aside class="notes">
            <p>
              To be honest I didn't know the word "ubiquitous" before I learnt
              about DDD, which means "existing or being everywhere at the same
              time".
            </p>
            <p>
              The idea is to use a shared vocabulary that both developers and
              business experts understand. This helps to avoid confusion and
              miscommunication, ensuring that everyone is on the same page.
            </p>
            <p>
              In the case of Astronoby, domain experts could be scientists
              interested in contributing to the project and having the
              scientific knowledge.
            </p>
          </aside>
        </section>
        <section>
          <h3>Ubiquitous Language</h3>
          <div class="row">
            <div class="col col-50">
              <p>‚ùå</p>
              <pre class="fragment visible" data-fragment-index="0">
                <code class="ruby">
  class MoonState
    def self.compute(state, time)
      new(
        time: time,
        state: state
      )
    end
  end
                </code>
              </pre>
            </div>
            <div class="col col-50">
              <p>‚úÖ</p>
              <pre class="fragment visible" data-fragment-index="1">
                <code class="ruby">
  class MoonPhase
    def self.full_moon(time)
      new(
        time: time,
        phase: FULL_MOON
      )
    end
  end
                </code>
              </pre>
            </div>
          </div>
          <aside class="notes">
            <p>
              Instead of using technical jargon like "MoonState" and "compute",
              which might make sense in to the developers or in some design
              patterns, we use a more descriptive name like "MoonPhase" and
              "full_moon" which refer to the actual business concept of a full
              moon.
            </p>
          </aside>
        </section>
        <section>
          <p>When DDD?</p>
          <p>Complex domain</p>
          <p>Collaboration</p>
          <aside class="notes">
            <p>
              When the domain is complex and collaboration is important between
              the business knowledge and the technical skills.
            </p>
            <p>
              If your business experts can't recognize their own concepts and
              workflows in your code structure, you might be missing notions
              or abstract too much.
            </p>
            <p>
              This makes sense in a project where the code serves as a
              documentation of the concepts and the workflows.
            </p>
          </aside>
        </section>
        <section>
          <h2>DDD in Astronoby</h2>
          <aside class="notes">
            <p>
              To get more into applying DDD in a real project, I am going to use
              my experience on Astronoby to illustrate bounded contexts and the
              separation of concerns.
            </p>
          </aside>
        </section>
        <section>
          <h3>Repositories</h3>
          <p>
            <code>Ephem</code>
          </p>
          <aside class="notes">
            <p>
              Repositories are used to retrieve and store entities
            </p>
            <p>
              In Astronoby, Ephem holds the raw data. Its purpose is not
              behaviour nor transformation, but data storage.
            </p>
          </aside>
        </section>
        <section>
          <p><code>Ephem</code></p>
          <pre>
            <code class="rb">
          ephem = Astronoby::Ephem.load("de440s.bsp")

          ephem[0, 3].position_vector_at(2460819)
          # => Vector[-71204709, -123739936, -53612310]
            </code>
          </pre>
          <aside class="notes">
            <p>
              The <code>Ephem</code> module is responsible for loading external
              data and making it available as raw vectors that the rest of the
              library will use and transform.
            </p>
            <p>
              As a repository, it is not responsible for any transformation or
              calculation, it just stores the original data.
            </p>
          </aside>
        </section>
        <section>
          <h3>Domain services</h3>
          <p><code>RisingTransitSettingEvents</code></p>
          <p><code>MoonPhases</code></p>
          <aside class="notes">
            <p>
              Domain services are used to perform operations. They are
              stateless and do not hold any data.
            </p>
          </aside>
        </section>
        <section>
          <p><code>RisingTransitSettingEvents</code></p>
          <pre>
            <code class="ruby">
    calculator =
      Astronoby::RisingTransitSettingEventsCalculator.new(
        observer: observer,
        target_body: Astronoby::Sun,
        ephem: ephem
      )

    events = calculator.events_on(date)

    events.rising_time
    # => 2025-05-23 05:54:08 +0200
            </code>
          </pre>
          <aside class="notes">
            <p>
              This module is responsible for calculating the rising, transit and
              setting times and coordinates of a celestial body.
            </p>
            <p>
              As a domain service, it is not responsible for the data storage,
              the data transformation or the data representation. It is only
              responsible for holding some logic and algorithms.
            </p>
            <p>
              It exposes a simple but intuitive API and returns an object with
              formatted data. The final object is not a domain service but an
              entity. The domain service only computes. We will talk about
              entities shortly.
            </p>
          </aside>
        </section>
        <section>
          <h3>Value objects</h3>
          <p><code>Angle</code></p>
          <p><code>Instant</code></p>
          <p><code>Distance</code></p>
          <aside class="notes">
            <p>
              Value objects are defined by their attributes
            </p>
            <p>
              In Astronoby, they represent fundamental physical values
            </p>
          </aside>
        </section>
        <section>
          <p><code>Angle</code></p>
          <pre>
            <code class="ruby">
        angle = Astronoby::Angle.from_degres(240).hours

        angle.hours
        # => 16.0

        angle.cos
        # => -0.5
            </code>
          </pre>
          <aside class="notes">
            <p>
              The <code>Angle</code> value object holds the angle value has a
              convenient API to exposes the value in different formats.
            </p>
          </aside>
        </section>
        <section>
          <h3>Entities</h3>
          <p><code>Jupiter</code></p>
          <p><code>Observer</code></p>
          <aside class="notes">
            <p>
              Entities are defined by their identity
            </p>
            <p>
              In Astronoby, they represent physical objects, they benefit from
              data from repositories and are used by domain services.
            </p>
          </aside>
        </section>
        <section>
          <p><code>Jupiter</code></p>
          <pre>
            <code class="ruby">
          jupiter = Astronoby::Jupiter.new(
            ephem: ephem,
            instant: instant
          )

          jupiter.apparent.distance.km
          # => 904241448
            </code>
          </pre>
          <aside class="notes">
            <p>
              The <code>Jupiter</code> entity holds transformed data that makes
              sense in its context. Its arttributes are the results of
              transformations and calculations, while the values are value
              objects.
            </p>
            <p>
              Their enriched data and identity is then used by domain services.
            </p>
          </aside>
        </section>
        <section>
          <h2>Value objects</h2>
          <aside class="notes">
            <p>
              I would like to focus on value objects. While entities,
              repositories and domain services could be implemented as regular
              Ruby objects with different behaviours, value objects have a
              different purpose.
            </p>
            <p>
              In the context of a presentation about DDD, value object represent
              major parts of the philosophy.
            </p>
          </aside>
        </section>
        <section>
          <p>Replaces primitives</p>
          <p>Encapsulates data</p>
          <p>No or little behaviour</p>
          <aside class="notes">
            <p>
              Value object can represent fundamental values and notions that
              are key to the program while not doing anything special. Their
              purpose is to encapsulate data and replace primitives like numbers
              or strings, to make the code more readable, testable and
              homogeneous.
            </p>
          </aside>
        </section>
        <section>
          <p><code>Time</code></p>
          <pre>
            <code class="rb">
                        time = Time.now

                        time.hour
                        # => 16

                        time.to_i
                        # => 1747917900
            </code>
          </pre>
          <aside class="notes">
            <p>
              <code>Time</code> is a good example of value object in the Ruby
              standard library. It encapsulates a point in time and provides
              methods to access its components like hour, minute.
            </p>
            <p>
              Generally value objects are immutable, while `Time` exposes
              several methods that modify the object, so it is not an absolute
              value object.
            </p>
          </aside>
        </section>
        <section>
          <pre>
            <code class="ruby">
              distance1 = Distance.from_meters(1000)
              distance2 = Distance.from_kilometers(1)

              distance1 == distance2
              # => true

              distance3 = distance1 + distance2

              distance3.to_meters
              # => 2000
            </code>
          </pre>
          <aside class="notes">
            <p>
              Value objects are useful when integrated in logic or formulas.
              With value equality, you can compare them without having to
              worry about their identity or their format.
            </p>
            <p>
              Here we can instantiate two different objects that represent the
              same physical value, therefore they should be seen as equal.
            </p>
            <p>
              They can be manipulated together, leading to new objects that
              represent the result of the operation.
            </p>
          </aside>
        </section>
        <section>
          <p>
            <code>Comparable</code>, <code>#<=></code>, <code>#+</code>
          </p>
          <br>
          <p>
            <code>Data</code>
          </p>
          <aside class="notes">
            <p>
              By just using the <code>Comparable</code> module and spaceship
              operator, your can easily implement your own value object. You
              can add arithmetic methods like we showed in the
              <code>Distance</code> object, but be careful with the unit of
              resulting operations. For example, adding two distances creates a
              new distance, while multiplying two distances creates an area,
              which is not the same physical notion.
            </p>
            <p>
              You can also use the newly introduced <code>Data</code> class that
              natively supports value equality and provides a nice syntax to
              define your own value objects.
            </p>
          </aside>
        </section>
        <section>
          <p><code>Without value object</code></p>
          <pre>
            <code class="rb">
  declination_radians = declination_degrees * Math::PI / 180
  latitude_radians = latitude_degrees * Math::PI / 180
  ha_radians = ha_hours * 15 * Math::PI / 180

  term = Math.sin(declination_radians) *
         Math.sin(latitude_radians) +
         Math.cos(declination_radians) *
         Math.cos(latitude_radians) *
         Math.cos(ha_radians)

  altitude_degrees = Math.asin(term)
            </code>
          </pre>
        </section>
        <section>
          <p><code>Astronoby::Angle</code></p>
          <pre>
            <code class="rb">
          term = declination.sin * latitude.sin +
                 declination.cos * latitude.cos * ha.cos

          altitude = Angle.asin(term)
            </code>
          </pre>
        </section>
        <section>
          <h2>From maths to Ruby</h2>
        </section>
        <section>
          <p>
            <img src="img/celestial-calculations.png" alt="Celestial Calculations" style="width: 800px">
          </p>
          <p>
            <small><em>Celestial Calculations</em> by J. L. Lawrence</small>
          </p>
          <aside class="notes">
            <p>
              Here is a screenshot from one of the book I used to develop
              some algorithms in Astronoby. As you can see it contains
              references to some formulas, uses Greek letters for notations,
              includes branches in the algorithms, and so on.
            </p>
            <p>
              This is challenging to convert these instructions first into Ruby
              code, then into testable Ruby code, and then into readable Ruby
              code.
            </p>
            <p>
              Each new formula, new notion, must make sense in the existing and
              if possible reuse notions that already exist.
            </p>
          </aside>
        </section>
        <section>
          <p>Identify responsibility</p>
        </section>
        <section>
          <blockquote>equation of the center for Earth</blockquote>
          <blockquote>
            Earth's true anomaly from the equation of the center
          </blockquote>
          <p>Domain service</p>
        </section>
        <section>
          <blockquote>Earth's heliocentric longitude</blockquote>
          <p>Entity</p>
        </section>
        <section>
          <blockquote>
            adjust [...] so that if falls in the
            <br>
            range [0¬∞, 360¬∞]
          </blockquote>
          <p>Value object</p>
        </section>
        <section>
          <h2>The importance of precision</h2>
        </section>
        <section>
          <p>Angular distances</p>
        </section>
        <section>
          <p>1 circle</p>
          <p>360 degrees (¬∞)</p>
        </section>
        <section>
          <p>Each degree</p>
          <p>60 arc-minutes</p>
        </section>
        <section>
          <p>Each arc-minute</p>
          <p>60 arc-seconds</p>
        </section>
        <section>
          <p>1 circle</p>
          <p>1,296,000 arc-seconds</p>
        </section>
        <section>
          <p>Full Moon</p>
          <p>0.5¬∞</p>
          <p>0¬∞ 30' 0"</p>
        </section>
        <section>
          <p>Mars at its closest</p>
          <p>0.007¬∞</p>
          <p>0¬∞ 0' 25"</p>
        </section>
        <section>
          <p>Precision is important in science</p>
          <p>
            <img src="img/dog-scientist.png" alt="Dog scientist" style="width: 400px">
          </p>
        </section>
        <section>
          <p>It's time for some data typing theory üéâ</p>
        </section>
        <section>
          <p><code>Integer</code></p>
          <p>Infinite precision</p>
          <p>Until your computer runs out of memory</p>
        </section>
        <section>
          <p><code>Float</code></p>
          <p>Double-precision floating-point (IEEE 754)</p>
          <p>Rounding errors</p>
        </section>
        <section>
          <pre>
            <code class="ruby">
              0.1 + 0.2 # => 0.30000000000000004
            </code>
          </pre>
        </section>
        <section>
          <p><code>Rational</code></p>
          <p>Exact representation of fractions</p>
          <pre>
            <code class="ruby">
      1/10.0 + 1/10.0 + ... + 1/10.0  # => 0.9999999999999999
      1/10r  + 1/10r  + ... + 1/10r   # => 1
            </code>
          </pre>
        </section>
        <section>
          <p><code>BigDecimal</code></p>
          <p>Arbitrary precision decimal numbers</p>
          <pre>
            <code class="ruby">
              require "bigdecimal"

              1.2345678901234567890123
              # => 1.2345678901234567

              BigDecimal("1.2345678901234567890123")
              # => 0.12345678901234567890123e1
            </code>
          </pre>
        </section>
        <section>
          <p>Difference between</p>
          <p>
            <small><code>1.234567890123456¬∞</code></small>
            <br>
            <small><code>1.234567890123457¬∞</code></small>
          </p>
          <p>smaller than any instrument resolution</p>
          <aside class="notes">
            A small dust grain or an atom located at an immense distance,
            far beyond our galaxy, might subtend such a minuscule angle
          </aside>
        </section>
        <section>
          <p>Pluto's angular size</p>
          <p>0.00003¬∞</p>
        </section>
        <section>
          <p>Deimos' angular size</p>
          <p>0.00000008¬∞</p>
        </section>
        <section>
          <p>Rounding error</p>
          <p>0.00000000000000004</p>
        </section>
        <section>
          <p>
            Astronomical models or instruments will fail before Ruby is imprecise
          </p>
        </section>
        <section>
          <h2>Performance</h2>
        </section>
        <section>
          <p>Things that can harm performance</p>
          <p>Inefficient algorithms</p>
          <p>Redundant or unnecessary operations</p>
          <p>Non optimized critical methods</p>
          <p>Lack of fine-tuned tools in the ecosystem</p>
        </section>
        <section>
          <p>Astronoby suffers from performance issues</p>
          <p>0.4 seconds mean time for sunrise/sunset times and position</p>
        </section>
        <section>
          <p>Many ways to improve the performance</p>
          <p>Cache repetitive operations</p>
          <p>Better algorithms</p>
          <p>Optimized algorithms</p>
        </section>
        <section>
          <p>It is fine to not use DDD or OOP when it's too heavy-weight</p>
        </section>
        <section>
          <p>Consider writing C modules for critical parts</p>
        </section>
			</div>
		</div>

		<script src="dist/reveal.js"></script>
		<script src="plugin/notes/notes.js"></script>
		<script src="plugin/markdown/markdown.js"></script>
		<script src="plugin/highlight/highlight.js"></script>
    <script src="plugin/math/math.js"></script>
    <script>
			// More info about initialization & config:
			// - https://revealjs.com/initialization/
			// - https://revealjs.com/config/
			Reveal.initialize({
				hash: true,
        controls: false,
        transition: 'none',
        progress: true,
        // slideNumber: true,

        mathjax2: {
          config: 'TeX-AMS_HTML-full',
          TeX: {
            Macros: {
              R: '\\mathbb{R}',
              set: [ '\\left\\{#1 \\; ; \\; #2\\right\\}', 2 ]
            }
          }
        },

				// Learn about plugins: https://revealjs.com/plugins/
				plugins: [
          RevealMarkdown,
          RevealHighlight,
          RevealNotes,
          RevealMath.MathJax2
        ]
			});
		</script>
	</body>
</html>
