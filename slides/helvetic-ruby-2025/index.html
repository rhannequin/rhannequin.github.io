<!doctype html>
<html lang="en">
	<head>
		<meta charset="utf-8">
		<meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"
    >

		<title>Modelling the Cosmos in Ruby</title>

		<link rel="stylesheet" href="dist/reset.css">
		<link rel="stylesheet" href="dist/reveal.css">
    <link rel="stylesheet" href="custom.css">
		<link rel="stylesheet" href="plugin/highlight/obsidian.css">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link
      rel="stylesheet"
      href="https://fonts.googleapis.com/css2?family=Prosto+One&display=swap">
	</head>
	<body>
		<div class="reveal">
			<div class="slides">
        <section>
          <h1 style="margin: 0">
            Modelling the Cosmos in Ruby
          </h1>
        </section>
        <section>
          <h2>The sky is a lie</h2>
          <aside class="notes">
            <p>
              Let's start with a hard truth. The sky you see is not what you
              think it is. It is a lie.
            </p>
          </aside>
        </section>
        <section>
          <p>We see what's in the past</p>
          <aside class="notes">
            <p>
              Because the speed of light is finite, everything we see is at
              least slightly in the past. When it comes to astronomy, delay can
              be seconds, minutes, days, years.
            </p>
          </aside>
        </section>
        <section>
          <p>Sunrise and sunset times are fake</p>
          <aside class="notes">
            <p>
              The atmosphere refracts light so much that when we witness a
              sunset, the Sun has actually set below the horizon for several
              minutes.
            </p>
          </aside>
        </section>
        <section>
          <p>The Pole Star is not at the celestial pole</p>
          <aside class="notes">
            <p>
              From our perspective, the Pole Star slightly wobbles around the
              celestial pole. Thousands of years ago, another star was way
              closer to this point.
            </p>
          </aside>
        </section>
        <section>
          <p>A day is not 24 hours</p>
          <aside class="notes">
            <p>
              The Earth rotates around its axis in 23 hours, 56 minutes and 4
              seconds. What we use in everyday life is called a mean solar day,
              because the actual solar day varies throughout the year.
            </p>
          </aside>
        </section>
        <section>
          <p>Build an accurate astronomy library with that</p>
          <p>
            <img src="img/cringe.png" style="width: 300px" alt="Cringe meme">
          </p>
        </section>
        <section>
          <h2>Hi, I'm R√©my</h2>
          <br>
          <p class="slightly-smaller-text">@rhannequin</p>
        </section>
        <section>
          <p>Senior developer at thoughtbot</p>
          <br>
          <p>
            <img
              src="img/thoughtbot.svg"
              alt="thoughtbot LOGO"
              style="width: 200px; border: 0; box-shadow: none">
          </p>
          <aside class="notes">
            <p>
              thoughtbot is a design and development consultancy. We help
              companies build and maintain their products while leveling up
              their team and processes. We operate remotely from the EMEA region
              and the Americas.
            </p>
          </aside>
        </section>
        <section>
          <p>In love with astronomy</p>
          <aside class="notes">
            <p>
              I am a passionate amateur astronomer. As you will see today, I try
              to combine my passion for astronomy and my love for programming.
            </p>
          </aside>
        </section>
        <section>
          <p>
            Let's meet and talk
            <br>
            ü™êüçîü§ñüíªüçø
          </p>
          <aside class="notes">
            <p>
              Don't hesitate to reach out to me if you want to talk about
              astronomy, programming, or anything else.
            </p>
          </aside>
        </section>
        <section>
          <h2>What are we going to talk about?</h2>
        </section>
        <section>
          <p>Complex domain models</p>
          <aside class="notes">
            <p>
              Astronomy is a complex domain, it's a good example to illustrate
              the challenges of domain modelling.
            </p>
          </aside>
        </section>
        <section>
          <p>Learn code design techniques</p>
          <aside class="notes">
            <p>
              We will learn about some code design techniques like oriented
              object design and domain driven design.
            </p>
          </aside>
        </section>
        <section>
          <p>Code readability for collaboration and education</p>
          <aside class="notes">
            <p>
              We will see how to write code that is easy to read and
              understand, so that we can share it with others.
            </p>
          </aside>
        </section>
        <section>
          <h2>Context: Astronoby</h2>
          <aside class="notes">
            <p>
              We are going to use Astronoby as a prop for the rest of the
              presentation.
            </p>
          </aside>
        </section>
        <section>
          <p>Astronomical data and events accessible in Ruby</p>
          <aside class="notes">
            <p>
              Astronoby is a Ruby gem I started working on a couple years ago
              which is meant to provide astronomical data and events in pure
              Ruby.
            </p>
          </aside>
        </section>
        <section>
          <p class="shorter-text">Position of planets in the sky ü™ê</p>
          <p class="shorter-text">Rising, transit and setting times üåÑ</p>
          <p class="shorter-text">Equinoxes and solstices times ‚òÄÔ∏è</p>
          <p class="shorter-text">Moon phases üåô</p>
          <aside class="notes">
            <p>
              So far it provides the position of major Solar System bodies,
              times for events like rising or setting, but also equinoxes and
              solstices. You can also compute the phases of the Moon.
            </p>
          </aside>
        </section>
        <section>
          <p>Future:</p>
          <p>Conjunctions, oppositions</p>
          <p>Eclipses</p>
          <p>Deep sky objects</p>
          <p>Stargazing planner</p>
          <aside class="notes">
            <p>
              I have big plans for the library and soon it will implement more
              events, more celestial bodies and more utilies.
            </p>
          </aside>
        </section>
        <section>
          <p>Increase scientific support in the Ruby ecosystem</p>
          <aside class="notes">
            <p>
              To compare two different programming languages, Python and Ruby
              are very close to each other, except some syntax differences and
              some features, they can basically do the same. But Ruby is not
              known for its scientific ecosystem, Python is. Ruby deserves to
              have scientific projects to inspire others to contribute to the
              ecosystem as one where science can happen.
            </p>
          </aside>
        </section>
        <section>
          <p>Azimuth: 123¬∞44‚Ä≤47‚Ä≥</p>
          <p>Altitude: 49¬∞26‚Ä≤13‚Ä≥</p>
          <p>
            <img
              src="img/mars.png"
              alt="Mars"
              style="width: 150px; border: 0; box-shadow: none">
          </p>
          <p><img src="img/geneva.jpg" alt="Geneva" style="width: 400px"></p>
          <aside class="notes">
            <p>
              Let's start with an example.
            </p>
            <p>
              These are the coordinates of planet Mars seen from Geneva when we
              started this talk.
            </p>
            <p>
              Let me present you the suite of physical notions and data
              manipulations that were needed to get to this point.
            </p>
          </aside>
        </section>
        <section>
          <div class="row">
            <div class="col-35 smaller-text">
              <p>
                <span>Solar System Barycenter</span>
                <span><br>Vector</span>
                <span><br>Light-time</span>
                <span><br>Precession</span>
                <span><br>Nutation</span>
                <span><br>Aberration</span>
                <span><br>Deflection</span>
                <span><br>Earth shape</span>
                <span><br>Terrestrial time</span>
              </p>
              <p style="text-align: left">
                <img
                  src="img/dead-inside.jpg"
                  alt="Dead Inside meme"
                  style="width: 100px; border-radius: 50%; margin-top: 50px;">
              </p>
            </div>
            <div class="col-65 small-text">
              <p>Barycentric position</p>
              <p>Geocentric astrometric position</p>
              <p>Geocentric apparent position</p>
              <p>Topocentric apparent position</p>
              <p>Equatorial coordinates</p>
              <p>Horizontal coordinates</p>
            </div>
          </div>
          <aside class="notes">
            <p>
              We have to deal with different time scales, different definitions
              of a position, apply the right corrections to the right objects,
              and deal with coordinates conversions.
            </p>
            <p>
              I am not going to go into details, and to be honest you don't even
              have to read the slide, but I wanted to show you the complexity of
              going from raw data and transforming it into the coordinates that
              can be useful to a human.
            </p>
          </aside>
        </section>
        <section>
          <p>
            How to deal with a large and complex domain?
          </p>
          <aside class="notes">
            <p>
              This was my complex example, but I know many of you face more
              complex domains in your projects.
            </p>
            <p>
              How to keep up with so many different notions? You need to define
              clearly the data you manipulate to be sure you're applying the
              right correction on the right object and extract the right data
              from it.
            </p>
          </aside>
        </section>
        <section>
          <h2>Domain-Driven Design</h2>
          <aside class="notes">
            <p>That's where Domain-Driven Design comes.</p>
          </aside>
        </section>
        <section>
          <h2>DDD? üëç</h2>
          <aside class="notes">
            <p>
              Quick poll, please raise your hand if you already heard of DDD.
            </p>
            <p>
              Now keep your hand up if you already used it in a project.
            </p>
            <p>
              Hopefully everyone will leave with at least additional
              knowledge about DDD.
            </p>
          </aside>
        </section>
        <section>
          <p>Introduced in 2003 by Eric Evans</p>
          <p>Reflects business domain</p>
          <p>Focus on core domain</p>
          <aside class="notes">
            <p>
              Domain-Driven Design is a development approach that focuses on
              creating systems that deeply reflect the underlying business
              domain they serve.
            </p>
            <p>
              It was introduced in 2003 by Eric Evans his book "Domain-Driven
              Design: Tackling Complexity in the Heart of Software"
            </p>
            <p>
              The main philosophy is to focus on the core domain, its logic, its
              meaning, and build an architecture that reflects it.
            </p>
          </aside>
        </section>
        <section>
          <div class="row">
            <div class="col-50">
              <p>‚ùå</p>
              <p
                class="fragment visible"
                data-fragment-index="0"
                style="font-size: 1em"
              >
                <small>Technical layers</small>
              </p>
              <p
                class="fragment visible"
                data-fragment-index="2"
                style="font-size: 1em"
              >
                <small>Large exhaustive models</small>
              </p>
              <br>
              <p
                class="fragment visible"
                data-fragment-index="4"
                style="font-size: 1em"
              >
                <small>Uniform objects</small>
              </p>
            </div>
            <div class="col-50">
              <p>‚úÖ</p>
              <p
                class="fragment visible"
                data-fragment-index="1"
                style="font-size: 1em"
              >
                <small>Business concepts</small>
              </p>
              <p
                class="fragment visible"
                data-fragment-index="3"
                style="font-size: 1em"
              >
                <small>Multiple models with explicit boudaries</small>
              </p>
              <p
                class="fragment visible"
                data-fragment-index="5"
                style="font-size: 1em"
              >
                <small>Entities and value objects</small>
              </p>
            </div>
          </div>
          <aside class="notes">
            <p>
              Domain-Driven Design fundamentally shifts how we approach software
              development. Instead of organizing code around technical concerns
              like databases and UI layers, DDD encourages us to structure our
              systems around the actual business concepts and processes they
              represent.
            </p>
            <p>
              We move away from monolithic models and technical jargon, toward
              bounded contexts with explicit boundaries and a shared language
              that both developers and business experts use consistently.
            </p>
            <p>
              The code itself becomes a reflection of how the business thinks
              and operates. Instead of treating all objects the same way, we
              distinguish between identity-based entities and attribute-based
              value objects.
            </p>
          </aside>
        </section>
        <section>
          <h3>Ubiquitous Language</h3>
          <aside class="notes">
            <p>
              Ubiquitous language is one of the main points of DDD.
            </p>
            <p>
              To be honest I didn't know the word "ubiquitous" before I learnt
              about DDD, which means "existing or being everywhere at the same
              time".
            </p>
            <p>
              The idea is to use a shared vocabulary that both developers and
              business experts understand. This helps to avoid confusion and
              miscommunication, ensuring that everyone is on the same page.
            </p>
            <p>
              In the case of Astronoby, domain experts could be scientists
              interested in contributing to the project and having the
              scientific knowledge.
            </p>
          </aside>
        </section>
        <section>
          <h3>Ubiquitous Language</h3>
          <div class="row">
            <div class="col col-50">
              <p>‚ùå</p>
              <pre><code class="language-ruby" style="font-size: 0.7em">
class MoonState
  def self.compute(state, time)
    new(
      time: time,
      state: state
    )
  end
end</code></pre>
            </div>
            <div class="col col-50">
              <p>‚úÖ</p>
              <pre><code class="language-ruby" style="font-size: 0.7em">
class MoonPhase
  def self.full_moon(time)
    new(
      time: time,
      phase: FULL_MOON
    )
  end
end</code></pre>
            </div>
          </div>
          <aside class="notes">
            <p>
              Instead of using technical jargon like "MoonState" and "compute"
              in the example on the left, which might make sense in to the
              developers or in some design patterns, we use a more descriptive
              name like "MoonPhase" and "full_moon" which refer to the actual
              business concept of a full moon.
            </p>
          </aside>
        </section>
        <section>
          <p>When DDD?</p>
          <p>Complex domain</p>
          <p>Collaboration</p>
          <aside class="notes">
            <p>
              So when do we apply DDD?
            </p>
            <p>
              When the domain is complex and collaboration is important between
              the business knowledge and the technical skills.
            </p>
            <p>
              If your business experts can't recognize their own concepts and
              workflows in your code structure, you might be missing notions
              or abstract too much. But only if you are interested in this kind
              of collaboration.
            </p>
          </aside>
        </section>
        <section>
          <p>Ruby ‚ù§Ô∏è DDD</p>
          <ul>
            <li>OOP</li>
            <li>Expressiveness</li>
            <li>Modules</li>
            <li>Metaprogramming</li>
          </ul>
          <aside class="notes">
            <p>
              Ruby is particularly well suited for DDD because of its
              object-oriented nature and its expressiveness. It allows us to
              create clear and concise representations of domain concepts.
            </p>
            <p>
              The use of modules in Ruby allows us to create reusable and
              composable components and to establish clear and semantic
              boundaries between different parts of the codebase.
            </p>
            <p>
              Metaprogramming can be used to create domain-specific languages
              that make the code more expressive and easier to read.
            </p>
          </aside>
        </section>
        <section>
          <h2>DDD in Astronoby</h2>
          <aside class="notes">
            <p>
              To get more into applying DDD in a real project, I am going to use
              my experience on Astronoby to illustrate bounded contexts and the
              separation of concerns.
            </p>
          </aside>
        </section>
        <section>
          <h3>Repositories</h3>
          <p>
            <code>Ephem</code>
          </p>
          <aside class="notes">
            <p>
              Let's start with repositories.
            </p>
            <p>
              They are used to retrieve and store entities.
            </p>
            <p>
              In Astronoby, Ephem holds the raw data. Its purpose is not
              behaviour nor transformation, but data storage.
            </p>
          </aside>
        </section>
        <section>
          <p><code>Ephem</code></p>
          <pre><code class="language-ruby">
  ephem = Astronoby::Ephem.load("de440s.bsp")

  ephem[0, 3].position_at(2460819)
  # => Vector[-71204709, -123739936, -53612310]</code></pre>
          <aside class="notes">
            <p>
              Here's an example.
            </p>
            <p>
              The <code>Ephem</code> module is responsible for loading external
              data and making it available as raw vectors that the rest of the
              library will use and transform.
            </p>
            <p>
              The method <code>position_at</code> computes a position vector
              which is the distance from Solar System barycenter to the object
              in the 3-dimensional space.
            </p>
            <p>
              As a repository, it is not responsible for any transformation or
              calculation, it just stores the original data.
            </p>
          </aside>
        </section>
        <section>
          <h3>Domain services</h3>
          <p><code>RiseTransitSetCalculator</code></p>
          <p><code>MoonPhases</code></p>
          <aside class="notes">
            <p>
              We then have domain services.
            </p>
            <p>
              They are used to perform operations. They are stateless and do not
              hold any data.
            </p>
            <p>
              In Astronoby, we have calculators for event times or for Moon
              phases.
            </p>
          </aside>
        </section>
        <section>
          <p><code>RiseTransitSetCalculator</code></p>
          <pre><code class="language-ruby" style="font-size: 0.8em">
calculator =
  Astronoby::RiseTransitSetCalculator.new(
    body: Astronoby::Sun,
    observer: observer,
    ephem: ephem
  )

event = calculator.event_on(date)
# => Astronoby::RiseTransitSetEvent object

event.rising_time
# => 2025-05-23 05:54:08 +0200</code></pre>
          <aside class="notes">
            <p>
              This module, for example, is responsible for calculating the
              rising, transit and setting times of a celestial body.
            </p>
            <p>
              As a domain service, it is not responsible for the data storage or
              the data representation. It is only responsible for holding some
              logic and algorithms.
            </p>
            <p>
              It exposes a simple but intuitive API and returns an object with
              formatted data. The final object is not a domain service but an
              entity or a value object. We will talk about these right after.
            </p>
          </aside>
        </section>
        <section>
          <h3>Value objects</h3>
          <p><code>Angle</code></p>
          <p><code>Instant</code></p>
          <p><code>Distance</code></p>
          <aside class="notes">
            <p>
              Value objects are objects defined by their attributes.
            </p>
            <p>
              In Astronoby, they represent fundamental mathematical and physical
              values.
            </p>
          </aside>
        </section>
        <section>
          <p><code>Angle</code></p>
          <pre><code class="language-ruby">
angle = Astronoby::Angle.from_degres(240).hours

angle.hours
# => 16.0

angle.cos
# => -0.5</code></pre>
          <aside class="notes">
            <p>
              The <code>Angle</code> value object holds the angle value and has
              a convenient API to expose it in different formats.
            </p>
          </aside>
        </section>
        <section>
          <h3>Entities</h3>
          <p><code>Jupiter</code></p>
          <p><code>Observer</code></p>
          <aside class="notes">
            <p>
              Finally, we have entities, which are defined by their identity.
            </p>
            <p>
              In Astronoby, they represent physical objects, they benefit from
              data from repositories and are used by domain services.
            </p>
          </aside>
        </section>
        <section>
          <p><code>Jupiter</code></p>
          <pre><code class="language-ruby">
        jupiter = Astronoby::Jupiter.new(
          ephem: ephem,
          instant: instant
        )

        jupiter.apparent.distance.km
        # => 904241448</code></pre>
          <aside class="notes">
            <p>
              Here, the <code>Jupiter</code> entity holds transformed data. Its
              attributes are the results of transformations and calculations,
              while the values are value objects.
            </p>
            <p>
              Their enriched data and identity is then used by domain services.
            </p>
          </aside>
        </section>
        <section>
          <img
            src="img/ddd-chart.png"
            alt="DDD Chart"
            style="width: 1000px; max-width: 500%; max-height: 500%; margin: 0">
          <aside class="notes">
            <p>
              Here's a chart that summarizes the different parts of DDD we just
              presented and how they interact with each other.
            </p>
            <p>
              As you can see, this is not a complexe architecture, the main
              point is to split the logic and the data into different kinds of
              objects that will behave in a specific way.
            </p>
            <p>
              I'm sure this is something many of you already do every day, so
              you might be using DDD without even knowing it.
            </p>
          </aside>
        </section>
        <section>
          <pre><code class="language-ruby" style="font-size: 0.7em; max-height: 550px;">
ephem = Astronoby::Ephem.load("inpop19a.bsp")

time = Time.utc(2025, 5, 23, 14, 45, 0)
instant = Astronoby::Instant.from_time(time)

geneva = Astronoby::Observer.new(
  latitude: Astronoby::Angle.from_degrees(46.2044),
  longitude: Astronoby::Angle.from_degrees(6.1432),
  elevation: Astronoby::Distance.from_meters(375)
)

sun = Astronoby::Sun.new(instant: instant, ephem: ephem)

topocentric = sun.observed_by(geneva)

topocentric.horizontal.altitude.degrees
# => 43.36620058310606</code></pre>
          <aside class="notes">
            <p>
              I would like to show you a simple example from Astronoby that
              highlights the explicit boundaries and domain-specific vocabulary
              that DDD promotes.
            </p>
          </aside>
        </section>
        <section>
          <pre><code
            class="language-ruby"
            style="font-size: 0.7em; max-height: 550px;"
            data-line-numbers="2|4-5|7-11|13|15|17-18">
ephem = Astronoby::Ephem.load("inpop19a.bsp")

time = Time.utc(2025, 5, 23, 14, 45, 0)
instant = Astronoby::Instant.from_time(time)

geneva = Astronoby::Observer.new(
  latitude: Astronoby::Angle.from_degrees(46.2044),
  longitude: Astronoby::Angle.from_degrees(6.1432),
  elevation: Astronoby::Distance.from_meters(375)
)

sun = Astronoby::Sun.new(instant: instant, ephem: ephem)

topocentric = sun.observed_by(geneva)

topocentric.horizontal.altitude.degrees
# => 43.36620058310606</code></pre>
          <aside class="notes">
            <p>
              We first have an <code>ephem</code> that loads the raw data from
              an ephemeris file. In DDD, it is a repository.
            </p>
            <p>
              Then, we have <code>instant</code>, a value object that
              represents a point in time. It handles the conversion of this time
              in different time scales when needed.
            </p>
            <p>
              <code>geneva</code> is an entity. It represents an observer here
              in Geneva, defined by their GPS coordinates. Note that each
              element is a value object as a separation of concerns. The
              observer represents a bounded context, and its components handle
              their own values.
            </p>
            <p>
              Then, we have the <code>sun</code>, an entity generated from the
              transformation of raw data from the <code>ephem</code> repository
              depending on the <code>instant</code> constraint.
            </p>
            <p>
              This entity exposes a method <code>observed_by</code> that
              generates a topocentric position, it describes a position in the
              sky centered on an observer on Earth. Note that I'm not using a
              synonym, but the actual term used by astronomers.
              <br>
              This method could actually be seen as a domain service. I
              preferred to keep it in the entity to have areadable API, but it
              could make sense to have a dedicated domain service.
            </p>
            <p>
              Finally, the generated <code>topocentric</code> object is also
              kind of a value object. It exposes its position through different
              coordinates types.
              <br>
              <code>horizontal</code> is the type we want to describe where the
              Sun is in the sky up and down, left and right, which itself,
              again, exposes attributes as value objects.
            </p>
          </aside>
        </section>
        <section>
          <pre><code class="language-ruby" style="font-size: 0.7em; max-height: 550px;">
ephem = Astronoby::Ephem.load("inpop19a.bsp")

time = Time.utc(2025, 5, 23, 14, 45, 0)
instant = Astronoby::Instant.from_time(time)

geneva = Astronoby::Observer.new(
  latitude: Astronoby::Angle.from_degrees(46.2044),
  longitude: Astronoby::Angle.from_degrees(6.1432),
  elevation: Astronoby::Distance.from_meters(375)
)

sun = Astronoby::Sun.new(instant: instant, ephem: ephem)

topocentric = sun.observed_by(geneva)

topocentric.horizontal.altitude.degrees
# => 43.36620058310606</code></pre>
          <aside class="notes">
            <p>
              And we finally have the altitude that can be displayed in
              multiple ways.
            </p>
            <p>
              I am not advocating for following this pattern constantly, but in
              the case of Astronoby, DDD is a good fit as every object
              corresponds to a physical notion that could be understood by
              scientists.
            </p>
          </aside>
        </section>
        <section>
          <h2>Value objects</h2>
          <aside class="notes">
            <p>
              I would like to focus on value objects. While entities,
              repositories and domain services could be seen as regular Ruby
              objects with different behaviors, value objects have a different
              purpose, they represent a major part of the DDD philosophy.
            </p>
          </aside>
        </section>
        <section>
          <p>Replace primitives</p>
          <p>Encapsulate data</p>
          <p>No or little behaviour</p>
          <aside class="notes">
            <p>
              Value objects can represent fundamental values and notions that
              are key to the program while not doing anything special. Their
              purpose is to encapsulate data and replace primitives like numbers
              or strings, to make the code more readable, testable and
              homogeneous.
            </p>
          </aside>
        </section>
        <section>
          <p><code>Time</code></p>
          <pre><code class="language-ruby">
                time = Time.now

                time.hour
                # => 16

                time.to_i
                # => 1747917900</code></pre>
          <aside class="notes">
            <p>
              <code>Time</code> is a good example of a value object in the Ruby
              standard library. It encapsulates a point in time and provides
              methods to access its components like hour, minute.
            </p>
            <p>
              Generally value objects are immutable, while <code>Time</code>
              exposes several methods that modify the object, so it is not an
              absolute value object.
            </p>
          </aside>
        </section>
        <section>
          <pre><code class="language-ruby">
    distance1 = Distance.from_meters(1000)
    distance2 = Distance.from_kilometers(1)

    distance1 == distance2
    # => true

    distance3 = distance1 + distance2

    distance3.to_meters
    # => 2000</code></pre>
          <aside class="notes">
            <p>
              Value objects are useful when integrated in logic or formulas.
              With value equality, you can compare them without having to
              worry about their identity or their format, which is the default
              in Ruby
            </p>
            <p>
              Here we can instantiate two different objects that represent the
              same physical value, therefore they should be seen as equal.
            </p>
            <p>
              They can be manipulated together, leading to new objects that
              represent the result of the operation.
            </p>
          </aside>
        </section>
        <section>
          <p>
            <code>Comparable</code>, <code>#<=></code>, <code>#+</code>
          </p>
          <br>
          <p>
            <code>Data</code>
          </p>
          <aside class="notes">
            <p>
              By just adding the <code>Comparable</code> module and implementing
              the spaceship operator, your can easily implement your own value
              object. You can add arithmetic methods like we showed in the
              <code>Distance</code> object, but be careful with the unit of
              resulting operations. For example, adding two distances creates a
              new distance, while multiplying two distances creates an area,
              which is a different physical notion.
            </p>
            <p>
              You can also use the newly <code>Data</code> class, introduced in
              Ruby 3.2, that natively supports value equality and provides a
              nice syntax to define your own value objects.
            </p>
          </aside>
        </section>
        <section>
          <p><code>Without value object</code></p>
          <pre><code class="language-ruby" style="font-size: 0.7em">
declination_radians = declination_degrees * Math::PI / 180
latitude_radians = latitude_degrees * Math::PI / 180
hour_angle_radians = hour_angle_hours * 15 * Math::PI / 180

ratio = Math.sin(declination_radians) *
        Math.sin(latitude_radians) +
        Math.cos(declination_radians) *
        Math.cos(latitude_radians) *
        Math.cos(hour_angle_radians)

altitude_radians = Math.asin(ratio)</code></pre>
          <aside class="notes">
            <p>
              Here is an example of a formula that computes the altitude of a
              celestial body. It deals with different notions like the
              declination, latitude or hour angle, but it is not necessary to
              know what they are to understand the formula.
            </p>
            <p>
              The code is difficult to read and understand, angles need to be
              converted in the right units before being used, which leads to
              verbose name for clarity.
            </p>
            <p>
              As a result, we have the altitude angle in radians, which will
              probably be converted in other units later.
            </p>
          </aside>
        </section>
        <section>
          <p><code>Astronoby::Angle</code></p>
          <pre><code class="language-ruby" style="font-size: 0.8em">
ratio = declination.sin * latitude.sin +
        declination.cos * latitude.cos * hour_angle.cos

altitude = Astronoby::Angle.asin(ratio)</code></pre>
          <p>
            <img
              src="img/wow.gif"
              alt="Rainbow drool meme"
              style="width: 75px">
          </p>
          <aside class="notes">
            <p>
              With value objects, we can use the same formula without worrying
              about the units. The <code>Angle</code> object will take care of
              the conversion and the representation.
            </p>
            <p>
              As a result, the altitude is an angle object, ready to be used in
              the rest of the codebase as-is.
            </p>
            <p>
              The code is much more readable and understandable in my opinion,
              and is easier to maintain.
            </p>
          </aside>
        </section>
        <section>
          <h2>Testing</h2>
          <aside class="notes">
            <p>
              While we are getting closer to the end of this talk, I think it is
              important to talk about testing.
            </p>
          </aside>
        </section>
        <section>
          <h3>DDD ‚ù§Ô∏è Testing</h3>
          <p>Well-defined objects</p>
          <p>Bounded contexts</p>
          <aside class="notes">
            <p>
              Ruby is a dynamically typed language, which requires investment in
              testing to ensure the integrity of the code.
            </p>
            <p>
              Part of the DDD philosophy is to write testable code. Ruby is
              particularly well suited for this aspect due to the strong
              testing culture in the ecosystem and community.
            </p>
            <p>
              With well-defined objects and bounded contexts, it is easy to
              write tests that cover the different parts of the codebase.
            </p>
          </aside>
        </section>
        <section>
          <h3>Pragmatism</h3>
          <p class="small-text">Source of truth: IMCCE, NASA/JPL</p>
          <p>
            <img src="img/imcce.png" alt="IMCCE" style="width: 700px">
          </p>
          <aside class="notes">
            <p>
              DDD is also a pragmatic choice for writing scientific code.
              Institutes and organizations provide data that can be used to
              test the algorithms and the code. They enforce the use of their
              own scientific domain, which is an opportunity but also a
              constraint. With my limited knowledge of real science, it is hard
              to know if the data is correct or not, so I need to rely on
              external sources to validate the results.
            </p>
            <p>
              This is a screenshot from the IMCCE website, a French institute on
              celestial mechanics. The domain and vocabulary are approximately
              the same as the one used in Astronoby. It helped me test my
              results step by step, but also use correct concepts and
              algorithms.
            </p>
            <p>
              This way, DDD helped having integrity and maintainability.
            </p>
          </aside>
        </section>
        <section>
          <h2>Performance</h2>
          <aside class="notes">
            <p>
              As a side and last note, I would like to talk about performance.
            </p>
          </aside>
        </section>
        <section>
          <h3>DDD & performance</h3>
          <p>Yes, but,</p>
          <aside class="notes">
            <p>
              DDD is a great approach to write maintainable and readable code.
              Nothing in its philosophy prevents you from writing performant
              code but it can lead to performance issues if not used carefully.
              It is a matter of how you use it and how you design your code.
            </p>
          </aside>
        </section>
        <section>
          <h3>What is your priority?</h3>
          <p>Readability</p>
          <p>Accuracy</p>
          <p>Performance</p>
          <aside class="notes">
            <p>
              The important point is to define your priorities. With Astronoby,
              I wanted to focus on readability and accuracy. I implemented
              the scientific domain and language for accuracy and
              maintainability, and DDD helped me achieve that.
            </p>
            <p>
              I also want a library that is performant, I can achieve it, but I
              won't find guidance in DDD for this aspect.
            </p>
          </aside>
        </section>
        <section>
          <h3>Performance</h3>
          <p>Algorithms</p>
          <p>Many objects</p>
          <p>Low-level interfaces</p>
          <aside class="notes">
            <p>
              To compute astronomical data, I need to find and test algorithms,
              implement them correctly and efficiently, and then optimise them
              if needed. DDD is not a magic wand, and in some perspectives, it
              can hurt the performance, for example by forcing to manipulate
              too many objects.
            </p>
            <p>
              Some critical parts of the code can be optimised by using
              low-level interfaces like C extensions. It wouldn't go against DDD
              to use them, but it requires extra care to integrate them in a
              codebase written with a specific philosophy in mind.
            </p>
          </aside>
        </section>
        <section>
          <h2>Conclusion</h2>
          <aside class="notes">
            <p>
              We did it! Let's wrap up now.
            </p>
          </aside>
        </section>
        <section>
          <h3>What we learnt</h3>
          <br>
          <p class="slightly-smaller-text">
            Domain-Driven Design is hard to pronounce
          </p>
          <br>
          <p class="slightly-smaller-text">
            DDD for managing complex domains
          </p>
          <br>
          <p class="slightly-smaller-text">
            Ruby expressiveness helps
          </p>
          <aside class="notes">
            <p>
              Throughout this presentation, we have seen how DDD can help manage
              complex domains.
            </p>
            <p>
              We have also seen how Ruby's expressiveness and object-oriented
              nature can help implement DDD in a clean and readable way.
            </p>
          </aside>
        </section>
        <section>
          <h3>Beyond astronomy</h3>
          <p class="slightly-smaller-text">
            1. Identify
          </p>
          <p class="slightly-smaller-text">
            2. Map the boundaries
          </p>
          <p class="slightly-smaller-text">
            3. Value objects
          </p>
          <p class="slightly-smaller-text">
            4. Separate
          </p>
          <p class="slightly-smaller-text">
            5. Don't overthink
          </p>
          <aside class="notes">
            <p>
              Many projects we all work on also have complex domains that
              require a clear understanding and implementation of the business
              concepts.
            </p>
            <p>
              To apply DDD to your own project, first identify your core domain.
              Talk to your stakeholders and document the key terms they use
              consistently.
            </p>
            <p>
              Then, map the boundaries between different parts of your system.
              Where does one context end and another begin?
            </p>
            <p>
              Start small with value objects. Look for primitive obsession in
              your code, places where you're passing around strings, numbers, or
              IDs that actually represent domain concepts.
            </p>
            <p>
              Separate your data access from your business logic. This makes
              it easier to test and maintain.
            </p>
            <p>
              Finally, remember that DDD is about making your code more
              expressive and maintainable, not about following rules perfectly.
              Prioritize what helps your team understand the domain.
            </p>
          </aside>
        </section>
        <section>
          <h2>Final Thoughts</h2>
          <div style="font-size: 80%">
            <p class="slightly-smaller-text">
              Good models illuminate complex realities
            </p>
            <p class="slightly-smaller-text">
              Code can be both educational and functional
            </p>
            <p class="slightly-smaller-text">
              Ruby deserves a place in scientific computing
            </p>
          </div>
          <aside class="notes">
            <p>
              Just as astronomical models help us understand the cosmos despite
              its complexity, good software illuminates complex business
              domains.
            </p>
            <p>
              With Astronoby and DDD, I've tried to show that code can be both
              educational and functional, teaching about astronomy through its
              very structure.
            </p>
            <p>
              And finally, I hope this project demonstrates that Ruby, with its
              expressive syntax and object-oriented nature, deserves a more
              prominent place in science.
            </p>
          </aside>
        </section>
        <section>
          <p>
            <img
              src="img/thoughtbot.svg"
              alt="thoughtbot LOGO"
              style="width: 300px; border: 0; box-shadow: none">
          </p>
          <aside class="notes">
            <p>
              To finish, I would like to give a special shoutout to thoughtbot
              for their support and for allowing me to work on Astronoby and
              collaborating with the community during investment time.
            </p>
          </aside>
        </section>
        <section data-background="img/suns.jpeg">
          <h2 style="margin-top: 450px; font-size: 2.5em">
            Thank you
          </h2>
        </section>
			</div>
		</div>

		<script src="dist/reveal.js"></script>
		<script src="plugin/notes/notes.js"></script>
		<script src="plugin/markdown/markdown.js"></script>
		<script src="plugin/highlight/highlight.js"></script>
    <script>
			// More info about initialization & config:
			// - https://revealjs.com/initialization/
			// - https://revealjs.com/config/
			Reveal.initialize({
				hash: true,
        controls: false,
        transition: 'none',
        progress: true,
        // slideNumber: true,

				// Learn about plugins: https://revealjs.com/plugins/
				plugins: [
          RevealMarkdown,
          RevealHighlight,
          RevealNotes,
        ]
			});
		</script>
	</body>
</html>
